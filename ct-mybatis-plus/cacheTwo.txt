mybatis二级缓存：
1.二级缓存区域是根据mapper的namespace划分的，相同namespace的mapper查询数据放在同一个区域，
  如果使用mapper代理方法每个mapper的namespace都不同，此时可以理解为二级缓存区域是根据mapper划分，
  也就是根据命名空间来划分的，如果两个mapper文件的命名空间一样，那样，他们就可以共享一个mapper缓存。
2.每次查询会先从缓存区域找，如果找不到从数据库查询，查询到数据将数据写入缓存。
3.Mybatis内部存储缓存使用一个HashMap，key为hashCode+sqlId+Sql语句。value为从查询出来映射生成的Java对象
  sqlSession执行insert、update、delete等操作commit提交后会清空缓存区域。
使用必备条件：
1.MyBatis支持二级缓存的总开关：全局配置变量参数   cacheEnabled=true
2.该select语句所在的Mapper，配置了<cache> 或<cached-ref>节点，并且有效
3.该select语句的参数 useCache=true
刷新缓存：
<insert id="insertUser" parameterType="cn.ssm.mybatis.po.User" flushCache="true"/>
在mapper的同一个namespace中，如果有其他insert、update、delete操作后都需要执行刷新缓存操作，来避免脏读。
这时我们只需要设置statement配置中的flushCache=“true“属性，就会默认刷新缓存，相反如果是false就不会了。
当然，不管开不开缓存刷新功能，你要是手动更改数据库表，那都肯定不能避免脏读的发生，那就属于手贱了。
<cache  eviction="FIFO"  flushInterval="60000"  size="512"  readOnly="true"/>
flushInterval：
（刷新间隔）可以被设置为任意的正整数，而且它们代表一个合理的毫秒形式的时间段。
默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新。
size：
（引用数目）可以被设置为任意正整数，要记住你缓存的对象数目和你运行环境的可用内存资源数目。
默认值是1024。
readOnly：
（只读）属性可以被设置为true或false。
只读的缓存会给所有调用者返回缓存对象的相同实例。
因此这些对象不能被修改。
这提供了很重要的性能优势。
可读写的缓存会返回缓存对象的拷贝（通过序列化）。
这会慢一些，但是安全，因此默认是false。
策略：
1.LRU – 最近最少使用的:移除最长时间不被使用的对象。
2.FIFO – 先进先出:按对象进入缓存的顺序来移除它们。
3.SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。
4.WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。

