redis和ehcache的比较：
1.ehcache直接在jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。
2.redis是通过socket访问到缓存服务，效率比ecache低，比数据库要快很多，
  处理集群和分布式缓存方便，有成熟的方案。如果是单个应用或者对缓存访问要求很高的应用，用ehcache。
  如果是大型系统，存在缓存共享、分布式部署、缓存内容很大的，建议用redis。
3.ehcache也有缓存共享方案，不过是通过RMI或者Jgroup多播方式进行广播缓存通知更新，
  缓存共享复杂，维护不方便；简单的共享可以，但是涉及到缓存恢复，大数据缓存，则不合适。
java.io.tmpdir：System.getProperty("java.io.tmpdir")

缓存配置:

xml配置方式：
diskStore:ehcache支持内存和磁盘两种存储
    path:指定磁盘存储的位置
defaultCache:默认的缓存
    maxEntriesLocalHeap=”10000”
    eternal=”false”
    timeToIdleSeconds=”120”
    timeToLiveSeconds=”120”
    maxEntriesLocalDisk=”10000000”
    diskExpiryThreadIntervalSeconds=”120”
    memoryStoreEvictionPolicy=”LRU”
cache ：自定的缓存，当自定的配置不满足实际情况时可以通过自定义（可以包含多个cache节点）
    name : 缓存的名称，可以通过指定名称获取指定的某个Cache对象
    maxElementsInMemory ：内存中允许存储的最大的元素个数，0代表无限个
    clearOnFlush：内存数量最大时是否清除。
    eternal ：设置缓存中对象是否为永久的，如果是，超时设置将被忽略，对象从不过期。
              根据存储数据的不同，例如一些静态不变的数据如省市区等可以设置为永不过时
    timeToIdleSeconds : 设置对象在失效前的允许闲置时间（单位：秒）。
                        仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。
    timeToLiveSeconds ：缓存数据的生存时间（TTL），也就是一个元素从构建到消亡的最大时间间隔值，
                        这只能在元素不是永久驻留时有效，如果该值是0就意味着元素可以停顿无穷长的时间。
    overflowToDisk ：内存不足时，是否启用磁盘缓存。
    maxEntriesLocalDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。
    maxElementsOnDisk：硬盘最大缓存个数。
    diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。
                           默认是30MB。每个Cache都应该有自己的一个缓冲区。
    diskPersistent：是否在VM重启时存储硬盘的缓存数据。默认值是false。
    diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。
编程方式配置:
    Cache cache = manager.getCache("mycache");
    CacheConfiguration config = cache.getCacheConfiguration();
    config.setTimeToIdleSeconds(60);
    config.setTimeToLiveSeconds(120);
    config.setmaxEntriesLocalHeap(10000);
    config.setmaxEntriesLocalDisk(1000000);

整合spring

@Cacheable
    表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，
    以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。
    这个注解可以用condition属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。
    可以使用key属性来指定key的生成规则。
    @Cacheable 支持如下几个参数：
    value：缓存位置名称，不能为空，如果使用EHCache，就是ehcache.xml中声明的cache的name, 指明将值缓存到哪个Cache中
    key：缓存的key，默认为空，既表示使用方法的参数类型及参数值作为key，支持SpEL，如果要引用参数值使用井号加参数名，
    如：#userId，
    一般来说，我们的更新操作只需要刷新缓存中某一个值，所以定义缓存的key值的方式就很重要，
    最好是能够唯一，因为这样可以准确的清除掉特定的缓存，而不会影响到其它缓存值 ，
    本例子中使用实体加冒号再加ID组合成键的名称，如”user:1”、”order:223123”等
    condition：触发条件，只有满足条件的情况才会加入缓存，默认为空，既表示全部都加入缓存，支持SpEL
@CachePut
    与@Cacheable不同，@CachePut不仅会缓存方法的结果，还会执行方法的代码段。它支持的属性和用法都与@Cacheable一致。
@CacheEvict
    与@Cacheable功能相反，@CacheEvict表明所修饰的方法是用来删除失效或无用的缓存数据。
    @CacheEvict 支持如下几个参数：
    value：缓存位置名称，不能为空，同上
    key：缓存的key，默认为空，同上
    condition：触发条件，只有满足条件的情况才会清除缓存，默认为空，支持SpEL
    allEntries：true表示清除value中的全部缓存，默认为false